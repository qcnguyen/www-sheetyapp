---
title: Best Practices
description: Learn best practices for using Sheety in production
slug: docs/guides/best-practices
---

# Best Practices

Follow these best practices to build reliable and secure applications with Sheety.

## Security

### 1. Protect Your API Keys

Never expose API keys in client-side code:

```javascript
// ❌ Bad - API key exposed in frontend
const apiKey = 'sk_live_abc123';
fetch('https://api.sheety.co/john/myproject/users', {
  headers: { 'Authorization': `Bearer ${apiKey}` }
});

// ✅ Good - Use environment variables
const apiKey = process.env.SHEETY_API_KEY;
```

### 2. Use HTTPS Only

Always use HTTPS for API requests to ensure data is encrypted in transit:

```javascript
// ✅ Correct
const url = 'https://api.sheety.co/john/myproject/users';

// ❌ Never use HTTP
const url = 'http://api.sheety.co/john/myproject/users';
```

### 3. Validate Input Data

Always validate and sanitize data before sending to the API:

```javascript
function validateEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}

function createUser(name, email, age) {
  // Validate inputs
  if (!name || name.trim().length === 0) {
    throw new Error('Name is required');
  }
  
  if (!validateEmail(email)) {
    throw new Error('Invalid email format');
  }
  
  if (age < 0 || age > 150) {
    throw new Error('Invalid age');
  }
  
  // Proceed with API call
  return fetch('https://api.sheety.co/john/myproject/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${process.env.SHEETY_API_KEY}`
    },
    body: JSON.stringify({
      user: { name, email, age }
    })
  });
}
```

## Performance

### 1. Implement Caching

Cache API responses to reduce unnecessary requests:

```javascript
class CachedSheetyClient {
  constructor(username, project, apiKey) {
    this.client = new SheetyClient(username, project, apiKey);
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
  }

  async get(sheet, id = null) {
    const cacheKey = `${sheet}-${id || 'all'}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.data;
    }
    
    const data = await this.client.get(sheet, id);
    this.cache.set(cacheKey, {
      data,
      timestamp: Date.now()
    });
    
    return data;
  }
}
```

### 2. Batch Operations

When possible, batch multiple operations:

```javascript
// ❌ Bad - Multiple sequential requests
async function updateMultipleUsers(updates) {
  for (const update of updates) {
    await fetch(`https://api.sheety.co/john/myproject/users/${update.id}`, {
      method: 'PUT',
      body: JSON.stringify({ user: update })
    });
  }
}

// ✅ Better - Parallel requests
async function updateMultipleUsers(updates) {
  const promises = updates.map(update =>
    fetch(`https://api.sheety.co/john/myproject/users/${update.id}`, {
      method: 'PUT',
      body: JSON.stringify({ user: update })
    })
  );
  
  return Promise.all(promises);
}
```

### 3. Use Pagination

For large datasets, always use pagination:

```javascript
async function getAllUsersWithPagination() {
  const limit = 100;
  let offset = 0;
  let allUsers = [];
  let hasMore = true;
  
  while (hasMore) {
    const response = await fetch(
      `https://api.sheety.co/john/myproject/users?limit=${limit}&offset=${offset}`
    );
    const data = await response.json();
    
    allUsers = [...allUsers, ...data.users];
    hasMore = data.users.length === limit;
    offset += limit;
  }
  
  return allUsers;
}
```

## Error Handling

### 1. Implement Retry Logic

Add retry logic for transient failures:

```javascript
async function fetchWithRetry(url, options, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return await response.json();
      }
      
      // Don't retry client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
      // Retry server errors (5xx)
      if (i === maxRetries - 1) {
        throw new Error(`Server error: ${response.status}`);
      }
      
      // Wait before retrying (exponential backoff)
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, i) * 1000)
      );
      
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => 
        setTimeout(resolve, Math.pow(2, i) * 1000)
      );
    }
  }
}
```

### 2. Handle Rate Limits

Respect rate limits and implement backoff:

```javascript
async function fetchWithRateLimiting(url, options) {
  const response = await fetch(url, options);
  
  if (response.status === 429) {
    const retryAfter = response.headers.get('Retry-After') || 60;
    console.log(`Rate limited. Retrying after ${retryAfter} seconds`);
    
    await new Promise(resolve => 
      setTimeout(resolve, retryAfter * 1000)
    );
    
    return fetchWithRateLimiting(url, options);
  }
  
  return response;
}
```

### 3. Log Errors Properly

Implement comprehensive error logging:

```javascript
async function safeApiCall(url, options) {
  try {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      const error = {
        status: response.status,
        statusText: response.statusText,
        url: url,
        timestamp: new Date().toISOString()
      };
      
      console.error('API Error:', error);
      
      // Send to error tracking service
      // trackError(error);
      
      throw new Error(`API call failed: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Network Error:', {
      message: error.message,
      url: url,
      timestamp: new Date().toISOString()
    });
    
    throw error;
  }
}
```

## Data Management

### 1. Structure Your Sheets Properly

Use clear, consistent column names:

```
✅ Good column names:
- firstName, lastName, email, createdAt
- product_name, product_price, product_category

❌ Bad column names:
- "First Name" (spaces)
- "user-email" (inconsistent naming)
- "Col1", "Col2" (unclear meaning)
```

### 2. Use Data Types Appropriately

Ensure data types are consistent:

```javascript
// ✅ Good - Consistent types
const user = {
  name: "John Doe",       // String
  age: 30,                // Number
  isActive: true,         // Boolean
  createdAt: "2024-01-01" // ISO date string
};

// ❌ Bad - Inconsistent types
const user = {
  name: "John Doe",
  age: "30",              // Should be number
  isActive: "yes",        // Should be boolean
  createdAt: 1704067200   // Hard to read timestamp
};
```

### 3. Implement Data Validation

Validate data on both client and server side:

```javascript
const userSchema = {
  name: { type: 'string', required: true, minLength: 2 },
  email: { type: 'email', required: true },
  age: { type: 'number', min: 0, max: 150 },
  isActive: { type: 'boolean', default: true }
};

function validateData(data, schema) {
  const errors = [];
  
  for (const [field, rules] of Object.entries(schema)) {
    if (rules.required && !data[field]) {
      errors.push(`${field} is required`);
    }
    
    if (rules.type === 'email' && data[field]) {
      if (!validateEmail(data[field])) {
        errors.push(`${field} must be a valid email`);
      }
    }
    
    // Add more validations as needed
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
```

## Testing

### 1. Use Test Environment

Separate test and production sheets:

```javascript
const config = {
  development: {
    username: 'john',
    project: 'myproject-dev',
    apiKey: process.env.DEV_API_KEY
  },
  production: {
    username: 'john',
    project: 'myproject',
    apiKey: process.env.PROD_API_KEY
  }
};

const env = process.env.NODE_ENV || 'development';
const sheetyConfig = config[env];
```

### 2. Mock API Calls in Tests

```javascript
// Using Jest
jest.mock('./sheety-client');

test('fetches users successfully', async () => {
  const mockUsers = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' }
  ];
  
  SheetyClient.prototype.get.mockResolvedValue({
    users: mockUsers
  });
  
  const users = await fetchUsers();
  expect(users).toEqual(mockUsers);
});
```

## Monitoring

### 1. Track API Usage

Monitor your API usage to stay within rate limits:

```javascript
class MonitoredSheetyClient {
  constructor(username, project, apiKey) {
    this.client = new SheetyClient(username, project, apiKey);
    this.requestCount = 0;
    this.startTime = Date.now();
  }

  async request(method, ...args) {
    this.requestCount++;
    
    // Log every 100 requests
    if (this.requestCount % 100 === 0) {
      const elapsed = (Date.now() - this.startTime) / 1000 / 60;
      const rate = this.requestCount / elapsed;
      console.log(`API Usage: ${this.requestCount} requests, ${rate.toFixed(2)} req/min`);
    }
    
    return this.client[method](...args);
  }
}
```

### 2. Set Up Alerts

Implement alerts for important events:

```javascript
async function apiCallWithAlerts(url, options) {
  try {
    const response = await fetch(url, options);
    
    if (response.status === 429) {
      // Alert: Rate limit reached
      sendAlert('Rate limit reached on Sheety API');
    }
    
    if (!response.ok) {
      // Alert: API error
      sendAlert(`Sheety API error: ${response.status}`);
    }
    
    return response;
  } catch (error) {
    // Alert: Network error
    sendAlert(`Sheety network error: ${error.message}`);
    throw error;
  }
}
```

## Summary

- **Security**: Protect API keys, use HTTPS, validate input
- **Performance**: Cache responses, batch operations, use pagination
- **Error Handling**: Implement retries, handle rate limits, log errors
- **Data Management**: Structure sheets properly, use consistent types
- **Testing**: Separate environments, mock API calls
- **Monitoring**: Track usage, set up alerts

Following these best practices will help you build robust, secure, and performant applications with Sheety.
